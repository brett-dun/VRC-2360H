#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    gyro,           sensorGyro)
#pragma config(Sensor, in2,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in3,    powerExpander,  sensorAnalog)
#pragma config(Sensor, dgtl7,  intakeEncoder,  sensorQuadEncoder)
#pragma config(Sensor, dgtl9,  ultrasonic,     sensorSONAR_inch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           leftMobileGoal, tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftMiddleDrive, tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           leftDRFB,      tmotorVex393_MC29, openLoop, encoderPort, I2C_4)
#pragma config(Motor,  port4,           leftDrive,     tmotorVex393HighSpeed_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port5,           chainBar,      tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           intake,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightDrive,    tmotorVex393HighSpeed_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port8,           rightDRFB,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           rightMiddleDrive, tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,          rightMobileGoal, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)


//CONSTANTS
#define WHEEL_DIAMETER 4.0 //Inches
#define DRIVE_RATIO 1.0 //Ratio = Out / In
#define TICKS 392.0 //High Torque (Normal) = 627.2; High Speed = 392.0; Turbo = 261.333; External = 360;
#define LCD_CONNECTED true
#define NUM_AUTON_OPTIONS 7 //1 is the minimum
#define LEFT_BUTTON (nLCDButtons == 1 || vexRT[Btn7L] || vexRT[Btn8L])
#define MIDDLE_BUTTON (nLCDButtons == 2 || vexRT[Btn7U] || vexRT[Btn7D] || vexRT[Btn8U] || vexRT[Btn8D])
#define RIGHT_BUTTON (nLCDButtons == 4 || vexRT[Btn7R] || vexRT[Btn8R])


//variables
bool skillsEnabled = false; //skills will not run
bool leftStart = true; //will not start on left side
short autoChoice = 0; //no autonomous will run


//supporting files
#include "vex.c" //include vex supporting code

#include "smart_motor.c" //include our custom smart motor library
#include "advanced_lcd.c" //include our custom advanced lcd library

#include "controller_layout.c" //contains the controller layout

#include "set_drive.c"
#include "drive_inches.c"
#include "turn_degrees.c"
#include "intake_cone.c"
#include "pid_task.c" //pid task for double reverse four bar and chain bar
#include "ultrasonic_task.c" //normalize ultrasonic values

#include "mobile.c" // 2 cones + mobile goal
#include "stationary.c" // 1 cone on stationary + 5 point zone mobile goal
#include "five_point.c" // 2 cones + 5 point zone mobile goal
#include "ten_point.c" // 2 cones + 10 point zone mobile goal
#include "twenty_two_point.c" // 1 cone + 20 point zone mobile goal
#include "twenty_four_point.c" // 2 cones + 20 point zone mobile goal
#include "skills.c" //programming skills code

#include "automatic_stacking.c" //code for automatic stacking during driver control

#include "pre_auton.c" //include pre-autonomous code
#include "autonomous.c" //include autonomous code
#include "usercontrol.c" //include user control code
